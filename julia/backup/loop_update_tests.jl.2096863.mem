        0 module ClassicalMC
        - 
        - using Test
        - using Random
        - using Profile
        - using Traceur
        - using StaticArrays
        - 
        - include("loop_update.jl")
        -  
        - function add_Jij!(unique_Jij, Jij, i, j, Jx, Jy, Jz, flag_nn)
        -     push!(unique_Jij,
        -         UniqueJij(SVector{3,Float64}(Jx, Jy, Jz), flag_nn))
        -     push!(Jij, (SpinIndex(i), SpinIndex(j), length(unique_Jij)))
        - end
        - 
        - function ring_plus_one_model()
        -     # 1D system of 4 spins with a periodic boundary condition.
        -     num_spins = 5
        -     loop_length = 4
        -     unique_Jij = UniqueJij[]
        -     Jij = []
        -     for ispin=1:loop_length-1
        -         add_Jij!(unique_Jij, Jij, ispin, ispin+1, 0.1, 0.5, 1.,1)
        -     end
        -     add_Jij!(unique_Jij, Jij, 1, loop_length, 0.1, 0.5, 1.,1)
        -     add_Jij!(unique_Jij, Jij, 1, num_spins, 0.2, 0.5, 100.,1)
        -     model = JModel(num_spins, unique_Jij, Jij)
        -     return model
        - end
        - 
        - 
        - function all_to_all_model(num_spins)
       64     unique_Jij = UniqueJij[]
       48     Jij = []
        0     for ispin=1:num_spins
        0         for jspin=ispin+1:num_spins
    43728             add_Jij!(unique_Jij, Jij, ispin, jspin, rand(), rand(), rand(), 1)
        -         end
        -     end
        0     model = JModel(num_spins, unique_Jij, Jij)
        0     return model
        - end
        - 
        - function mk_test_spins(num_spins)
        -     spins = fill((0.,0.,0.),num_spins)
        -     temp = 0
        -     for idx in 1:num_spins
        -       theta = 10*rand()
        -       spins[idx] = (cos(theta),sin(theta),0)
        -     end
        -     return spins
        - end
        - 
        - function test_find_loop(model::JModel)
        0     u = SingleSpinFlipUpdater(model)
        0     num_spins = model.num_spins
        - 
      224     work = fill(0, num_spins)
        0     first_spin_idx = rand(1:num_spins)
        - 
        0     max_coord_num = maximum(u.coord_num)
      208     candidate_second_spin_idx = zeros(UInt,max_coord_num)
        0     for ins in 1:u.nn_coord_num[first_spin_idx]
        0         candidate_second_spin_idx[ins] = u.nn_sites[ins,first_spin_idx]
        -     end
      208     second_spin_idx = rand(candidate_second_spin_idx[1:u.nn_coord_num[first_spin_idx]])     
        - 
        -     max_loop_length = num_spins
      224     spin_idx_on_loop = zeros(UInt, max_loop_length)
        -     #spins = mk_test_spins(num_spins)
        -     sum_boundary_spins = MVector(0.,0.,0.)
        - 
      544     spins = fill((0.,0.,0.),num_spins)
        0     for i in 1:num_spins
        0         theta  = 10*rand(Random.GLOBAL_RNG)
        0         spins[i] = (cos(theta),sin(theta),0.)
        -     end
        - 
        0     loop_length,sum_boundary_spins = find_loop(spins,
        -                                                spin_idx_on_loop,
        -                                                u,
        -                                                first_spin_idx,
        -                                                second_spin_idx, 
        -                                                max_loop_length, 
        -                                                work, 
        -                                                true, 
        -                                                false)
        0     println(loop_length)
        0     @assert loop_length > 0
       96     @assert all(work .== 0)
        - 
        -     # for check detailed balance condition satisfied,test if find_loop() could find inverse loop.
      224     cp_spins_on_loop = copy(spin_idx_on_loop)
        0     first_spin_idx_inv  = spin_idx_on_loop[loop_length]
        0     second_spin_idx_inv = spin_idx_on_loop[loop_length-1]
        0     loop_length_inv,sum_boundary_spins_inv = find_loop(spins,spin_idx_on_loop,u,first_spin_idx_inv,
        -                                                            second_spin_idx_inv,max_loop_length,work,false,false)
        - 
      464     @test all(reverse(spin_idx_on_loop[1:loop_length]) .== cp_spins_on_loop[1:loop_length])
        -     
        0     println("loop length: ", loop_length)
        0     @assert loop_length > 2
        0     @assert mod(loop_length, 2) == 0
        -    
      160     new_spins_on_loop = fill((0.,0.,-1.), loop_length)
        -     #new_spins_on_loop = mk_test_spins(num_spins)
        0     dE = compute_dE_loop(u, loop_length, spin_idx_on_loop, spins, new_spins_on_loop, work, true)
        - 
      544     new_spins = copy(spins)
        0     for i in 1:loop_length
        0         new_spins[spin_idx_on_loop[i]] = new_spins_on_loop[i]
        -     end
        0     dE_ref = compute_energy(model, new_spins) - compute_energy(model, spins)
        - 
        0     println("dE: ", dE)
      592     @test isapprox(dE, dE_ref)
        - end
        - 
        - if abspath(PROGRAM_FILE) == @__FILE__
        -     println("unit test results")
        -     
        -     #DEBUG
        -     #=
        -     Random.seed!(10)
        -     model  = ring_plus_one_model()
        -     println("ring_plus_one_model results")
        -     test_find_loop(model)
        -     =# 
        - 
        -     # for compile
        -     Random.seed!(10)
        -     model = all_to_all_model(20)
        - 
        -     Profile.clear_malloc_data()
        - 
        -     Random.seed!(10)
        -     model = all_to_all_model(20)
        -     println("all_to_all_model results")
        -     test_find_loop(model)
        - end
        - end
        - 
        - end
