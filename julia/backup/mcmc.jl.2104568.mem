        - using LinearAlgebra
        - using StaticArrays
        - using CPUTime
        - using Random
        - 
        - const SpinIndex = UInt32
        - 
        - const IsingSpin = Int8
        - const HeisenbergSpin = Tuple{Float64,Float64,Float64}
        - const UniqueJijIdx = UInt8
        - 
        - export JModel, SingleSpinFlipUpdater
        - 
        - struct UniqueJij
        -     Jxyz::SVector{3,Float64}
        -     flag_nn::UInt8
        - end
        - 
        - struct JModel
        -     # List of non-zero entries of Jij
        -     num_spins::Int
        -     unique_Jij::Vector{UniqueJij}
        -     Jij::Vector{Tuple{SpinIndex,SpinIndex,UInt8}}
        - end
        - 
        - 
        - # Read non-zero elements in the right-upper triangle part of Jij
        - function JModel(Jij_file::String, num_spins::Int64)
        -     unique_Jij = UniqueJij[]
        -     Jij = Tuple{SpinIndex,SpinIndex,UInt8}[]
        -     open(Jij_file, "r" ) do fp
      176         @assert num_spins == parse(Int64, readline(fp)) "!match num_spins. See 2d.ini and head of Jij.txt"
        - 
       32         num_unique_Jij = parse(Int, readline(fp))
        0         for i in 1:num_unique_Jij
      640             str     = split(readline(fp))
        0             i_read  = parse(Float64,  str[1])
        0             val_x   = parse(Float64,  str[2])
        0             val_y   = parse(Float64,  str[3])
        0             val_z   = parse(Float64,  str[4])
        0             flag_nn = parse(UInt8,    str[5])
        0             if i_read != i
        0                 error("Invalid input for unique Jij!")
        -             end
        0             Jxy = SVector{3,Float64}(val_x, val_y, val_z)
      272             push!(unique_Jij, UniqueJij(Jxy, flag_nn))
        -         end
        - 
       32         num_Jij_elems = parse(Int64, readline(fp))
466560000         resize!(Jij, num_Jij_elems)
        0         for ielem in 1:num_Jij_elems
12380636448             str      = split(readline(fp))
        0             i        = parse(SpinIndex, str[1])
        0             j        = parse(SpinIndex, str[2])
        0             uJij_idx = parse(UInt8,     str[3])
        0             if i >= j
        0                 error("Only right-upper triangle part must be given.")
        -             end
        0             if i > num_spins || i <= 0  || j > num_spins || j <= 0
        0                 error("i or j is out of the range [1, num_spins].")
        -             end
        0             if uJij_idx > num_unique_Jij
        0                 error("Invalid index for unique Jij!")
        -             end
        0             Jij[ielem] = (i, j, uJij_idx)
        -         end
        -     end
        - 
        -     return JModel(num_spins, unique_Jij, Jij)
        - end
        - 
        - 
        - function compute_energy(model::JModel, spins::AbstractVector{IsingSpin})
        -     return -sum([intr[3] * spins[intr[1]] * spins[intr[2]] for intr in model.Jij])
        - end
        - 
        - function compute_energy(model::JModel, spins::AbstractVector{HeisenbergSpin})
        - 
        -     energy = 0.0
        - 
        -     """
        -     for intr in model.Jij
        -         for j in 1:3
        -             energy += intr[j+2] * spins[intr[1]][j] * spins[intr[2]][j]
        -         end
        -     end
        -     """
        0     for intr in model.Jij
        0         spin1 = spins[intr[1]]
        0         spin2 = spins[intr[2]]
        0         uj_idx = intr[3]
        0         for j in 1:3
        0             energy += model.unique_Jij[uj_idx].Jxyz[j] * spin1[j] * spin2[j]
        -         end
        -     end
        -     
        0     return -energy
        - end
        - 
        - function propose_unifo()
        -    work = MVector(0.0, 0.0)
        -    i = 0
        -    s = 0.0
        -    while true
        -        for i=1:2
        -            work[i] = 2 * rand() - 1
        -        end
        -        s  = work[1]^2 + work[2]^2
        -        if s < 1
        -            break
        -        end
        -    end
        -    sqrt_tmp = sqrt(1-s)
        -    return 2*work[1]*sqrt_tmp, 2*work[2]*sqrt_tmp, 1-(2*s)
        - 
        - end
        - 
        - struct SingleSpinFlipUpdater
        -     num_spins::Int
        -     unique_Jij::Vector{UniqueJij}
        -     coord_num::Vector{UInt16}
        -     connection::Matrix{Tuple{SpinIndex,UInt8}}
        -     nn_coord_num::Vector{UInt16}
        -     nn_sites::Matrix{SpinIndex}
        - end
        - 
        - function get_J(updater, ispin, icoord)
        -     jspin, uidx = updater.connection[icoord, ispin]
        -     return jspin,
        -      updater.unique_Jij[uidx].Jxyz[1],
        -      updater.unique_Jij[uidx].Jxyz[2],
        -      updater.unique_Jij[uidx].Jxyz[3]
        - end
        - 
        - function SingleSpinFlipUpdater(model::JModel)
        0     num_spins = model.num_spins
        0     Jij = model.Jij
        - 
 77760048     coord_num = zeros(Int, num_spins)
        - 
        -     # Compute coord_num
 19440048     coord_num = zeros(UInt16, num_spins)
 19440048     nn_coord_num = zeros(UInt16, num_spins)
        0     for i_pair in eachindex(model.Jij)
        0         Jij_pair = Jij[i_pair]
        0         i, j = Jij_pair[1:2]
        0         coord_num[i] += 1
        0         coord_num[j] += 1
        0         if model.unique_Jij[Jij_pair[3]].flag_nn == 1
        0             nn_coord_num[i] += 1
        0             nn_coord_num[j] += 1
        -         end
        -     end
        0     max_coord_num = maximum(coord_num)
        0     max_nn_coord_num = maximum(nn_coord_num)
        - 
        -     # (idx of connected site, index of unique Jij, is_nn)
622080048     connection = Matrix{Tuple{SpinIndex,UInt8}}(undef, max_coord_num, num_spins)
 19440048     coord_idx = ones(UInt16, num_spins)
 19440048     nn_coord_idx = ones(UInt16, num_spins)
155520048     nn_sites = fill(typemax(SpinIndex), (max_nn_coord_num, num_spins))
        0     for i_pair in eachindex(model.Jij)
        0         Jij_pair = Jij[i_pair]
        0         i, j = Jij_pair[1:2]
        0         connection[coord_idx[i], i] = (j, Jij_pair[3])
        0         connection[coord_idx[j], j] = (i, Jij_pair[3])
        0         coord_idx[i] += 1
        0         coord_idx[j] += 1
        0         if model.unique_Jij[Jij_pair[3]].flag_nn == 1
        0             nn_sites[nn_coord_idx[i], i] = j
        0             nn_sites[nn_coord_idx[j], j] = i
        0             nn_coord_idx[i] += 1
        0             nn_coord_idx[j] += 1
        -         end
        -     end
        - 
        0     return SingleSpinFlipUpdater(num_spins, model.unique_Jij, coord_num, connection, nn_coord_num, nn_sites)
        - end
        - 
        - 
        - function one_sweep(updater::SingleSpinFlipUpdater, beta::Float64, model::JModel, spins::AbstractVector{IsingSpin})
        -     dE::Float64 = 0
        -     for ispin in 1:model.num_spins
        -         si_old = spins[ispin]
        -         # Compute effective field from the rest of spins
        -         eff_h::Float64 = 0.0
        -         for ic in 1:updater.coord_num[ispin]
        -             jsite, Jx, Jy, Jz = get_J(updater, ispin, ic)
        -             eff_h += Jz * spins[jsite]
        -         end
        - 
        -         # Flip spin
        -         dE_ud = -2 * eff_h
        -         prob_up = 1/(1 + exp(beta * dE_ud))
        -         if rand() < prob_up
        -             spins[ispin] = 1
        -         else
        -             spins[ispin] = -1
        -         end
        - 
        -         # Compute energy change
        -         dE += - eff_h * (spins[ispin] - si_old)
        -     end
        - 
        -     return dE
        - end
        - 
        - function effective_field(spins::AbstractVector{HeisenbergSpin}, updater, ispin)
        -     eff_h::HeisenbergSpin = (0.0, 0.0, 0.0)
        -     for ic in 1:updater.coord_num[ispin]
        -         c = updater.connection[ic, ispin]
        -         jsite, Jx, Jy, Jz = get_J(updater, ispin, ic)
        -         jspin = spins[jsite]
        -         eff_h = eff_h .+ (Jx*jspin[1], Jy*jspin[2], Jz*jspin[3])
        -     end
        -     eff_h
        - end
        - 
        - function one_sweep(updater::SingleSpinFlipUpdater, beta::Float64, model::JModel, spins::AbstractVector{HeisenbergSpin})
        -     dE::Float64 = 0
        -     num_acc = 0
        -     for ispin in 1:model.num_spins
        -         # Compute effective field from the rest of spins
        -         eff_h = effective_field(spins, updater, ispin)
        - 
        -         # Propose a new spin state
        -         si_new = propose_unifo()
        -          
        -         # Flip spin
        -         dE_prop = -dot(si_new .- spins[ispin], eff_h)
        -         if rand() < exp(-beta*dE_prop)
        -             spins[ispin] = si_new
        -             dE += dE_prop
        -             num_acc += 1
        -         end
        - 
        -         
        -         # Over relaxation.
        -         spins[ispin] = (2*dot(eff_h, spins[ispin])/(norm(eff_h)^2)) .* eff_h .- spins[ispin]
        -                 
        -     end
        - 
        -     return dE, num_acc/model.num_spins
        - end
        - 
        - 
        - 
        - function gaussian_move(updater::SingleSpinFlipUpdater, beta::Float64, model::JModel, spins::AbstractVector{HeisenbergSpin}, xy::Bool=false)
        -     dE::Float64 = 0
        0     sigma_g     = sqrt(beta^-1)
        -     num_acc     = 0
        0     coeff_z     = xy ? 0.0 : 1.0
        0     for ispin in 1:model.num_spins
        -         # Compute effective field from the rest of spins
        0         eff_h = effective_field(spins, updater, ispin)
        - 
        -         # Propose a new spin direction : Gaussian trial move 
        0         si_new = spins[ispin] .+ sigma_g .* (randn(Random.GLOBAL_RNG), randn(Random.GLOBAL_RNG), coeff_z*randn(Random.GLOBAL_RNG))
        0         si_new = si_new ./ norm(si_new)
        -  
        -         # Flip spin
        0         dE_prop = -dot(si_new .- spins[ispin], eff_h)
        0         if rand(Random.GLOBAL_RNG) < exp(-beta*dE_prop)
        0             spins[ispin] = si_new
        0             dE += dE_prop
        0             num_acc += 1
        -         end
        -         
        -         # Over relaxation.
        0         spins[ispin] = (2*dot(eff_h, spins[ispin])/(norm(eff_h)^2)) .* eff_h .- spins[ispin]
        -     end
        - 
        0     return dE, num_acc/model.num_spins
        - end
        - 
        - 
