2020年 5月 8日 金曜日 20時50分06秒 JST
Variables
  #self#::Core.Compiler.Const(Main.ClassicalMC.multi_loop_update!, false)
  loop_updater::Main.ClassicalMC.LoopUpdater{Tuple{Float64,Float64,Float64}}
  num_trial::Int64
  updater::SingleSpinFlipUpdater
  beta::Float64
  max_length::Int64
  spins::Array{Tuple{Float64,Float64,Float64},1}
  verbose::Bool
  work::Array{Int64,1}
  spins_idx_on_loop::Array{UInt64,1}
  new_spins_on_loop::Array{Tuple{Float64,Float64,Float64},1}
  num_spins::Int64
  max_coord_num::UInt16
  dE::Float64
  num_accept::Int64
  num_loop_found::Int64
  @_17::UNION{NOTHING, TUPLE{INT64,INT64}}
  i::Int64
  t1_s::UInt64
  first_spin_idx::Int64
  candidate_second_spin_idx::Array{UInt64,1}
  nn_coord_num::UInt16
  @_23::UNION{NOTHING, TUPLE{INT64,INT64}}
  second_spin_idx::UInt64
  loop_length::Int64
  @_26::Int64
  sum_boundary_spins::Tuple{Float64,Float64,Float64}
  t1_e::UInt64
  t2_s::UInt64
  before_flipped_spins::Array{Tuple{Float64,Float64,Float64},1}
  dE_loop::Float64
  temp_r::Float64
  t2_e::UInt64
  t3_s::UInt64
  cp_spins_idx_on_loop::Array{UInt64,1}
  first_spin_idx_inv::UInt64
  second_spin_idx_inv::UInt64
  loop_length_inv::Int64
  @_39::Int64
  sum_boundary_spins_inv::Tuple{Float64,Float64,Float64}
  t3_e::UInt64
  ins::Int64
  @_43::Bool
  @_44::Bool

Body::Tuple{Float64,Float64,Float64}
1 ──        (work = Base.getproperty(loop_updater, :work))
│           (spins_idx_on_loop = Base.getproperty(loop_updater, :spins_on_loop))
│           (new_spins_on_loop = Base.getproperty(loop_updater, :new_spins))
│           (num_spins = Base.getproperty(updater, :num_spins))
│    %5   = Base.getproperty(updater, :coord_num)::Array{UInt16,1}
│           (max_coord_num = Main.ClassicalMC.maximum(%5))
│           (dE = 0.0)
│           (num_accept = 0)
│           (num_loop_found = 0)
│    %10  = (1:num_trial)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│           (@_17 = Base.iterate(%10))
│    %12  = (@_17 === nothing)::Bool
│    %13  = Base.not_int(%12)::Bool
└───        goto #21 if not %13
2 ┄─        Core.NewvarNode(:(second_spin_idx))
│           Core.NewvarNode(:(loop_length))
│           Core.NewvarNode(:(@_26))
│           Core.NewvarNode(:(sum_boundary_spins))
│           Core.NewvarNode(:(t1_e))
│           Core.NewvarNode(:(t2_s))
│           Core.NewvarNode(:(before_flipped_spins))
│           Core.NewvarNode(:(dE_loop))
│           Core.NewvarNode(:(temp_r))
│           Core.NewvarNode(:(t2_e))
│           Core.NewvarNode(:(t3_s))
│           Core.NewvarNode(:(cp_spins_idx_on_loop))
│           Core.NewvarNode(:(first_spin_idx_inv))
│           Core.NewvarNode(:(second_spin_idx_inv))
│           Core.NewvarNode(:(loop_length_inv))
│           Core.NewvarNode(:(@_39))
│           Core.NewvarNode(:(sum_boundary_spins_inv))
│           Core.NewvarNode(:(t3_e))
│    %33  = @_17::Tuple{Int64,Int64}::Tuple{Int64,Int64}
│           (i = Core.getfield(%33, 1))
│    %35  = Core.getfield(%33, 2)::Int64
│           (t1_s = Main.ClassicalMC.time_ns())
│    %37  = (1:num_spins)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│           (first_spin_idx = Main.ClassicalMC.rand(%37))
│           (candidate_second_spin_idx = Main.ClassicalMC.zeros(Main.ClassicalMC.UInt, max_coord_num))
│    %40  = Base.getproperty(updater, :nn_coord_num)::Array{UInt16,1}
│           (nn_coord_num = Base.getindex(%40, first_spin_idx))
│    %42  = (1:nn_coord_num)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│           (@_23 = Base.iterate(%42))
│    %44  = (@_23 === nothing)::Bool
│    %45  = Base.not_int(%44)::Bool
└───        goto #5 if not %45
3 ┄─ %47  = @_23::Tuple{Int64,Int64}::Tuple{Int64,Int64}
│           (ins = Core.getfield(%47, 1))
│    %49  = Core.getfield(%47, 2)::Int64
│    %50  = Base.getproperty(updater, :nn_sites)::Array{UInt32,2}
│    %51  = ins::Int64
│    %52  = Base.getindex(%50, %51, first_spin_idx)::UInt32
│           Base.setindex!(candidate_second_spin_idx, %52, ins)
│           (@_23 = Base.iterate(%42, %49))
│    %55  = (@_23 === nothing)::Bool
│    %56  = Base.not_int(%55)::Bool
└───        goto #5 if not %56
4 ──        goto #3
5 ┄─ %59  = candidate_second_spin_idx::Array{UInt64,1}
│    %60  = (1:nn_coord_num)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│    %61  = Base.getindex(%59, %60)::Array{UInt64,1}
│           (second_spin_idx = Main.ClassicalMC.rand(%61))
│    %63  = Main.ClassicalMC.find_loop(spins, spins_idx_on_loop, updater, first_spin_idx, second_spin_idx, max_length, work, verbose)::Tuple{Int64,Tuple{Float64,Float64,Float64}}
│    %64  = Base.indexed_iterate(%63, 1)::Core.Compiler.PartialStruct(Tuple{Int64,Int64}, Any[Int64, Core.Compiler.Const(2, false)])
│           (loop_length = Core.getfield(%64, 1))
│           (@_26 = Core.getfield(%64, 2))
│    %67  = Base.indexed_iterate(%63, 2, @_26::Core.Compiler.Const(2, false))::Core.Compiler.PartialStruct(Tuple{Tuple{Float64,Float64,Float64},Int64}, Any[Tuple{Float64,Float64,Float64}, Core.Compiler.Const(3, false)])
│           (sum_boundary_spins = Core.getfield(%67, 1))
│    %69  = (loop_length == 0)::Bool
└───        goto #7 if not %69
6 ──        (@_43 = %69)
└───        goto #8
7 ── %73  = Main.ClassicalMC.mod(loop_length, 2)::Int64
└───        (@_43 = %73 !== 0)
8 ┄─        goto #10 if not @_43
9 ──        goto #19
10 ─        (num_loop_found = num_loop_found + 1)
│           (t1_e = Main.ClassicalMC.time_ns())
│           (t2_s = Main.ClassicalMC.time_ns())
│    %80  = spins_idx_on_loop::Array{UInt64,1}
│    %81  = (1:loop_length)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│    %82  = Base.getindex(%80, %81)::Array{UInt64,1}
│    %83  = Base.getindex(spins, %82)::Array{Tuple{Float64,Float64,Float64},1}
│           (before_flipped_spins = Main.ClassicalMC.copy(%83))
│           Main.ClassicalMC.reflect_spins_on_loop!(loop_length, spins, new_spins_on_loop, spins_idx_on_loop, updater, sum_boundary_spins)
│           (dE_loop = Main.ClassicalMC.compute_dE_loop(updater, loop_length, spins_idx_on_loop, spins, new_spins_on_loop, work, verbose))
│    %87  = Base.getproperty(Main.ClassicalMC.Random, :GLOBAL_RNG)::Core.Compiler.Const(Random._GLOBAL_RNG(), false)
│           (temp_r = Main.ClassicalMC.rand(%87))
│    %89  = temp_r::Float64
│    %90  = -beta::Float64
│    %91  = (%90 * dE_loop)::Float64
│    %92  = Main.ClassicalMC.exp(%91)::Float64
│    %93  = (%89 < %92)::Bool
└───        goto #12 if not %93
11 ─ %95  = new_spins_on_loop::Array{Tuple{Float64,Float64,Float64},1}
│    %96  = (1:loop_length)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│    %97  = Base.getindex(%95, %96)::Array{Tuple{Float64,Float64,Float64},1}
│    %98  = spins_idx_on_loop::Array{UInt64,1}
│    %99  = (1:loop_length)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│    %100 = Base.getindex(%98, %99)::Array{UInt64,1}
│           Base.setindex!(spins, %97, %100)
│           (num_accept = num_accept + 1)
└───        goto #13
12 ─        goto #19
13 ─        (t2_e = Main.ClassicalMC.time_ns())
│           (t3_s = Main.ClassicalMC.time_ns())
│    %107 = spins_idx_on_loop::Array{UInt64,1}
│    %108 = (1:loop_length)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│    %109 = Base.getindex(%107, %108)::Array{UInt64,1}
│           (cp_spins_idx_on_loop = Main.ClassicalMC.copy(%109))
│           (first_spin_idx_inv = Base.getindex(spins_idx_on_loop, loop_length))
│    %112 = spins_idx_on_loop::Array{UInt64,1}
│    %113 = (loop_length - 1)::Int64
│           (second_spin_idx_inv = Base.getindex(%112, %113))
│    %115 = Main.ClassicalMC.find_loop(spins, spins_idx_on_loop, updater, first_spin_idx_inv, second_spin_idx_inv, max_length, work, verbose)::Tuple{Int64,Tuple{Float64,Float64,Float64}}
│    %116 = Base.indexed_iterate(%115, 1)::Core.Compiler.PartialStruct(Tuple{Int64,Int64}, Any[Int64, Core.Compiler.Const(2, false)])
│           (loop_length_inv = Core.getfield(%116, 1))
│           (@_39 = Core.getfield(%116, 2))
│    %119 = Base.indexed_iterate(%115, 2, @_39::Core.Compiler.Const(2, false))::Core.Compiler.PartialStruct(Tuple{Tuple{Float64,Float64,Float64},Int64}, Any[Tuple{Float64,Float64,Float64}, Core.Compiler.Const(3, false)])
│           (sum_boundary_spins_inv = Core.getfield(%119, 1))
│    %121 = spins_idx_on_loop::Array{UInt64,1}
│    %122 = (1:loop_length)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│    %123 = Base.getindex(%121, %122)::Array{UInt64,1}
│    %124 = Main.ClassicalMC.reverse(%123)::Array{UInt64,1}
│    %125 = (%124 != cp_spins_idx_on_loop)::Bool
└───        goto #15 if not %125
14 ─        (@_44 = %125)
└───        goto #16
15 ─        (@_44 = loop_length !== loop_length_inv)
16 ┄        goto #18 if not @_44
17 ─        Base.setindex!(spins, before_flipped_spins, cp_spins_idx_on_loop)
│           (num_loop_found = num_loop_found - 1)
│           (num_accept = num_accept - 1)
└───        goto #19
18 ─        (t3_e = Main.ClassicalMC.time_ns())
└───        (dE = dE + dE_loop)
19 ┄        (@_17 = Base.iterate(%10, %35))
│    %138 = (@_17 === nothing)::Bool
│    %139 = Base.not_int(%138)::Bool
└───        goto #21 if not %139
20 ─        goto #2
21 ┄ %142 = dE::Float64
│    %143 = (num_loop_found / num_trial)::Float64
│    %144 = (num_accept / num_trial)::Float64
│    %145 = Core.tuple(%142, %143, %144)::Tuple{Float64,Float64,Float64}
└───        return %145
Overhead ╎ [+additional indent] Count File:Line; Function
=========================================================
 1╎1  @Base/arraymath.jl:52; *(::Int64, ::Array{Float64,1})
  ╎74 @Base/client.jl:484; _start()
  ╎ 74 @Base/client.jl:288; exec_options(::Base.JLOptions)
  ╎  74 @Base/Base.jl:377; include(::Module, ::String)
  ╎   74 /Users/hiroshi/git/lecture/julia/profile_loop_update.jl:129; profile_loop_update(::String)
  ╎    74 /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/Profile/src/Profile.jl:28; macro expansion
  ╎     1  /Users/hiroshi/git/lecture/julia/loop_update.jl:228; multi_loop_update!(::Main.ClassicalMC.LoopUpdater{Tuple{Float64,Float64,Float64}}, ::Int64, ::SingleSpinFlipUpdater, ::Float64, ::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Bool)
  ╎    ╎ 1  @Base/array.jl:500; zeros
  ╎    ╎  1  @Base/array.jl:504; zeros
  ╎    ╎   1  @Base/baseext.jl:25; Array
  ╎    ╎    1  @Base/boot.jl:414; Array
 1╎    ╎     1  @Base/boot.jl:405; Array
  ╎     1  /Users/hiroshi/git/lecture/julia/loop_update.jl:233; multi_loop_update!(::Main.ClassicalMC.LoopUpdater{Tuple{Float64,Float64,Float64}}, ::Int64, ::SingleSpinFlipUpdater, ::Float64, ::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Bool)
  ╎    ╎ 1  @Base/array.jl:795; getindex
  ╎    ╎  1  @Base/array.jl:360; similar
 1╎    ╎   1  @Base/boot.jl:405; Array
  ╎     5  /Users/hiroshi/git/lecture/julia/loop_update.jl:235; multi_loop_update!(::Main.ClassicalMC.LoopUpdater{Tuple{Float64,Float64,Float64}}, ::Int64, ::SingleSpinFlipUpdater, ::Float64, ::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Bool)
  ╎    ╎ 5  /Users/hiroshi/git/lecture/julia/loop_update.jl:35; find_loop
  ╎    ╎  3  /Users/hiroshi/git/lecture/julia/loop_update.jl:83; find_loop(::Array{Tuple{Float64,Float64,Float64},1}, ::Array{UInt64,1}, ::SingleSpinFlipUpdater, ::Int64, ::UInt64, ::Int64, ::Array{Int64,1}, ::Bool, ::Bool)
  ╎    ╎   3  @Base/array.jl:795; getindex
  ╎    ╎    3  @Base/array.jl:360; similar
 3╎    ╎     3  @Base/boot.jl:405; Array
  ╎    ╎  1  /Users/hiroshi/git/lecture/julia/loop_update.jl:84; find_loop(::Array{Tuple{Float64,Float64,Float64},1}, ::Array{UInt64,1}, ::SingleSpinFlipUpdater, ::Int64, ::UInt64, ::Int64, ::Array{Int64,1}, ::Bool, ::Bool)
  ╎    ╎   1  @Base/array.jl:795; getindex
  ╎    ╎    1  @Base/array.jl:360; similar
 1╎    ╎     1  @Base/boot.jl:405; Array
  ╎    ╎  1  /Users/hiroshi/git/lecture/julia/loop_update.jl:113; find_loop(::Array{Tuple{Float64,Float64,Float64},1}, ::Array{UInt64,1}, ::SingleSpinFlipUpdater, ::Int64, ::UInt64, ::Int64, ::Array{Int64,1}, ::Bool, ::Bool)
  ╎    ╎   1  @Base/range.jl:597; iterate
 1╎    ╎    1  @Base/promotion.jl:398; ==
  ╎     3  /Users/hiroshi/git/lecture/julia/loop_update.jl:249; multi_loop_update!(::Main.ClassicalMC.LoopUpdater{Tuple{Float64,Float64,Float64}}, ::Int64, ::SingleSpinFlipUpdater, ::Float64, ::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Bool)
  ╎    ╎ 1  @Base/abstractarray.jl:980; getindex
  ╎    ╎  1  @Base/multidimensional.jl:727; _getindex
  ╎    ╎   1  @Base/multidimensional.jl:739; _unsafe_getindex(::IndexLinear, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{UInt64,1})
  ╎    ╎    1  @Base/abstractarray.jl:626; similar
  ╎    ╎     1  @Base/array.jl:361; similar
  ╎    ╎    ╎ 1  @Base/boot.jl:414; Array
 1╎    ╎    ╎  1  @Base/boot.jl:405; Array
 1╎    ╎ 1  @Base/array.jl:352; copy
  ╎    ╎ 1  @Base/array.jl:795; getindex
  ╎    ╎  1  @Base/array.jl:360; similar
 1╎    ╎   1  @Base/boot.jl:405; Array
 1╎     58 /Users/hiroshi/git/lecture/julia/loop_update.jl:250; multi_loop_update!(::Main.ClassicalMC.LoopUpdater{Tuple{Float64,Float64,Float64}}, ::Int64, ::SingleSpinFlipUpdater, ::Float64, ::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Bool)
  ╎    ╎ 8  /Users/hiroshi/git/lecture/julia/loop_update.jl:136; reflect_spins_on_loop!(::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{UInt64,1}, ::SingleSpinFlipUpdater, ::Tuple{Float64,Float64,Float64})
  ╎    ╎  3  @Base/array.jl:603; collect
  ╎    ╎   3  @Base/array.jl:609; _collect
  ╎    ╎    3  @Base/array.jl:576; _similar_for
  ╎    ╎     3  @Base/abstractarray.jl:628; similar
  ╎    ╎    ╎ 3  @Base/abstractarray.jl:636; similar
  ╎    ╎    ╎  3  @Base/boot.jl:414; Array
 3╎    ╎    ╎   3  @Base/boot.jl:405; Array
 1╎    ╎  5  @Base/arraymath.jl:52; *(::Int64, ::Array{Float64,1})
  ╎    ╎   4  @Base/broadcast.jl:809; broadcast_preserving_zero_d
  ╎    ╎    4  @Base/broadcast.jl:820; materialize
  ╎    ╎     4  @Base/broadcast.jl:840; copy
  ╎    ╎    ╎ 1  @Base/broadcast.jl:864; copyto!
  ╎    ╎    ╎  1  @Base/broadcast.jl:900; copyto!
  ╎    ╎    ╎   1  @Base/abstractarray.jl:75; axes
  ╎    ╎    ╎    1  @Base/tuple.jl:157; map
  ╎    ╎    ╎     1  @Base/range.jl:320; OneTo
  ╎    ╎    ╎    ╎ 1  @Base/range.jl:311; OneTo
 1╎    ╎    ╎    ╎  1  @Base/promotion.jl:409; max
  ╎    ╎    ╎ 3  @Base/broadcast.jl:196; similar
  ╎    ╎    ╎  3  @Base/abstractarray.jl:670; similar
  ╎    ╎    ╎   3  @Base/abstractarray.jl:671; similar
  ╎    ╎    ╎    3  @Base/boot.jl:422; Array
  ╎    ╎    ╎     3  @Base/boot.jl:414; Array
 3╎    ╎    ╎    ╎ 3  @Base/boot.jl:405; Array
  ╎    ╎ 1  /Users/hiroshi/git/lecture/julia/loop_update.jl:148; reflect_spins_on_loop!(::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{UInt64,1}, ::SingleSpinFlipUpdater, ::Tuple{Float64,Float64,Float64})
  ╎    ╎  1  @Base/array.jl:603; collect
  ╎    ╎   1  @Base/array.jl:609; _collect
  ╎    ╎    1  @Base/array.jl:576; _similar_for
  ╎    ╎     1  @Base/abstractarray.jl:628; similar
  ╎    ╎    ╎ 1  @Base/abstractarray.jl:636; similar
  ╎    ╎    ╎  1  @Base/boot.jl:414; Array
 1╎    ╎    ╎   1  @Base/boot.jl:405; Array
 1╎    ╎ 48 /Users/hiroshi/git/lecture/julia/loop_update.jl:149; reflect_spins_on_loop!(::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{UInt64,1}, ::SingleSpinFlipUpdater, ::Tuple{Float64,Float64,Float64})
  ╎    ╎  3  @Base/arraymath.jl:39; -(::Array{Float64,1}, ::Array{Float64,1})
  ╎    ╎   3  @Base/broadcast.jl:809; broadcast_preserving_zero_d
  ╎    ╎    3  @Base/broadcast.jl:820; materialize
  ╎    ╎     3  @Base/broadcast.jl:840; copy
  ╎    ╎    ╎ 3  @Base/broadcast.jl:196; similar
  ╎    ╎    ╎  3  @Base/abstractarray.jl:670; similar
  ╎    ╎    ╎   3  @Base/abstractarray.jl:671; similar
  ╎    ╎    ╎    3  @Base/boot.jl:422; Array
  ╎    ╎    ╎     3  @Base/boot.jl:414; Array
 3╎    ╎    ╎    ╎ 3  @Base/boot.jl:405; Array
  ╎    ╎  6  @Base/operators.jl:529; *
  ╎    ╎   6  @Base/arraymath.jl:52; *(::Float64, ::Array{Float64,1})
  ╎    ╎    6  @Base/broadcast.jl:809; broadcast_preserving_zero_d
  ╎    ╎     6  @Base/broadcast.jl:820; materialize
  ╎    ╎    ╎ 6  @Base/broadcast.jl:840; copy
  ╎    ╎    ╎  6  @Base/broadcast.jl:196; similar
  ╎    ╎    ╎   6  @Base/abstractarray.jl:670; similar
  ╎    ╎    ╎    6  @Base/abstractarray.jl:671; similar
  ╎    ╎    ╎     6  @Base/boot.jl:422; Array
  ╎    ╎    ╎    ╎ 6  @Base/boot.jl:414; Array
 6╎    ╎    ╎    ╎  6  @Base/boot.jl:405; Array
  ╎    ╎  30 @Base/tuple.jl:230; Tuple
27╎    ╎   30 @Base/tuple.jl:258; _totuple
  ╎    ╎    2  @Base/array.jl:605; collect
  ╎    ╎     2  @Base/array.jl:621; _collect_indices
  ╎    ╎    ╎ 2  @Base/boot.jl:422; Array
  ╎    ╎    ╎  2  @Base/boot.jl:414; Array
 2╎    ╎    ╎   2  @Base/boot.jl:405; Array
  ╎    ╎  8  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:1657; normalize
  ╎    ╎   2  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:1657; normalize(::Array{Float64,1}, ::Int64)
  ╎    ╎    2  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:607; norm(::Array{Float64,1}, ::Int64)
  ╎    ╎     2  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/dense.jl:105; norm2(::Array{Float64,1})
  ╎    ╎    ╎ 1  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:477; generic_norm2(::Array{Float64,1})
  ╎    ╎    ╎  1  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:536; normInf
 1╎    ╎    ╎   1  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:452; generic_normInf
 1╎    ╎    ╎ 1  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:478; generic_norm2(::Array{Float64,1})
  ╎    ╎   1  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:1658; normalize(::Array{Float64,1}, ::Int64)
  ╎    ╎    1  @Base/abstractarray.jl:916; isempty
 1╎    ╎     1  @Base/promotion.jl:398; ==
  ╎    ╎   5  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/generic.jl:1659; normalize(::Array{Float64,1}, ::Int64)
  ╎    ╎    5  /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/LinearAlgebra.jl:347; copy_oftype
 5╎    ╎     5  @Base/array.jl:352; copy
  ╎     5  /Users/hiroshi/git/lecture/julia/loop_update.jl:251; multi_loop_update!(::Main.ClassicalMC.LoopUpdater{Tuple{Float64,Float64,Float64}}, ::Int64, ::SingleSpinFlipUpdater, ::Float64, ::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Bool)
 1╎    ╎ 1  @Base/array.jl:0; compute_dE_loop(::SingleSpinFlipUpdater, ::Int64, ::Array{UInt64,1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Int64,1}, ::Bool)
  ╎    ╎ 1  /Users/hiroshi/git/lecture/julia/loop_update.jl:170; compute_dE_loop(::SingleSpinFlipUpdater, ::Int64, ::Array{UInt64,1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Int64,1}, ::Bool)
 1╎    ╎  1  @Base/range.jl:597; iterate
  ╎    ╎ 1  /Users/hiroshi/git/lecture/julia/loop_update.jl:186; compute_dE_loop(::SingleSpinFlipUpdater, ::Int64, ::Array{UInt64,1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Int64,1}, ::Bool)
 1╎    ╎  1  @Base/array.jl:787; getindex
  ╎    ╎ 1  /Users/hiroshi/git/lecture/julia/loop_update.jl:187; compute_dE_loop(::SingleSpinFlipUpdater, ::Int64, ::Array{UInt64,1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Int64,1}, ::Bool)
  ╎    ╎  1  @Base/operators.jl:529; *
 1╎    ╎   1  @Base/float.jl:405; *
  ╎    ╎ 1  /Users/hiroshi/git/lecture/julia/loop_update.jl:192; compute_dE_loop(::SingleSpinFlipUpdater, ::Int64, ::Array{UInt64,1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Tuple{Float64,Float64,Float64},1}, ::Array{Int64,1}, ::Bool)
  ╎    ╎  1  @Base/operators.jl:529; *
 1╎    ╎   1  @Base/float.jl:405; *
  ╎     1  /Users/hiroshi/git/lecture/julia/loop_update.jl:296; multi_loop_update!(::Main.ClassicalMC.LoopUpdater{Tuple{Float64,Float64,Float64}}, ::Int64, ::SingleSpinFlipUpdater, ::Float64, ::Int64, ::Array{Tuple{Float64,Float64,Float64},1}, ::Bool)
  ╎    ╎ 1  @Base/range.jl:597; iterate
 1╎    ╎  1  @Base/promotion.jl:398; ==
Total snapshots: 78
2020年 5月 8日 金曜日 20時50分26秒 JST
