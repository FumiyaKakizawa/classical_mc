  2975576 module ClassicalMC
        - 
        - export solve,get_param,read_temps,read_Jij,read_spin_config,read_triangles
        - 
        - include("mcmc.jl")
        - include("accumulator.jl")
        - include("replica_exchange.jl")
        - include("loop_update.jl")
        - include("measure_mc.jl")
        - 
        - using Random
        - using ConfParser
        - using ArgParse
        - using MPI
        - using Test
        - using CPUTime
        - using HDF5
        - using Profile
        - 
        - 
        - # Read a list of temperatures
        - function read_temps(temperature_file::String)
       80     temps = Vector{Float64}(undef, 0)
        0     num_temps = 0
       32     open(temperature_file) do file
      176         num_temps = parse(Int64, readline(file))
       64         for l in 1:num_temps
       32             temp = parse(Float64, readline(file))
       80             push!(temps, temp)
        -         end
        -     end
        - 
        -     # Check if temperatures are in ascending order or descending order
       64     if !all(temps[1:num_temps-1] .< temps[2:num_temps]) && !all(temps[1:num_temps-1] .> temps[2:num_temps])
        0         error("Temperatures must be given either in ascending order or in descending order!")
        -     end
        - 
        0     return temps
        - end
        - 
        - 
        - # Distribute temperature over MPI processes
        - function distribute_temps(rank, num_temps, num_proc)
       64     num_temps_local = fill(trunc(Int, num_temps/num_proc), (num_proc,))
        0     left_over = mod(num_temps, num_proc)
       64     num_temps_local[1:left_over] .+= 1
      480     @test sum(num_temps_local) == num_temps
       64     start_idx = sum(num_temps_local[1:rank]) + 1
        0     end_idx = start_idx + num_temps_local[rank+1] - 1
        - 
        0     return start_idx, end_idx
        - end
        - 
        - # Read non-zero elements in the right-upper triangle part of Jij
        - """
        - function read_Jij(Jij_file::String, num_spins::Int64)
        -     Jij = Vector{Tuple{SpinIndex,SpinIndex,Float64,Float64,Float64,Int64}}(undef, 0)
        -     open(Jij_file, "r" ) do fp
        -         
        -         @assert num_spins == parse(Int64, readline(fp)) "!match num_spins. See 2d.ini and head of Jij.txt"
        - 
        -         num_Jij_elems = parse(Int64, readline(fp))
        -         for i in 1:num_Jij_elems
        -             str     = split(readline(fp))
        -             i       = parse(SpinIndex, str[1])
        -             j       = parse(SpinIndex, str[2])
        -             val_x   = parse(Float64,   str[3])
        -             val_y   = parse(Float64,   str[4])
        -             val_z   = parse(Float64,   str[5])
        -             flag_nn = parse(Int64,     str[6])
        -             if i >= j
        -                 error("Only right-upper triangle part must be given.")
        -             end
        -             if i > num_spins || i < 0  || j > num_spins || j < 0
        -                 error("i or j is out of the range [1, num_spins].")
        -             end
        -             push!(Jij, (i, j, val_x, val_y, val_z,flag_nn))
        -         end
        -     end
        -     return Jij
        - end
        - """
        - 
        - 
        - function read_triangles(file_name::String,num_spins::Int64)
        -    
        0     L = Int(sqrt(num_spins/3))
      544     triangles = fill((0,0,0),L^2)
        - 
       64     open(file_name,"r") do fp
        - 
      352         @assert L^2 == parse(Int64, readline(fp)) "!match number of triangles. See 2d.ini and head of utriangles.txt and dtriangles.txt!"
        - 
        0         for i in 1:L^2
     5472             str = split(readline(fp))
        0             s1 = parse(Int64, str[1])
        0             s2 = parse(Int64, str[2])
        0             s3 = parse(Int64, str[3])
        0             triangles[i] = (s1,s2,s3)
        -         end
        -     end
        - 
        0     return triangles
        - end
        - 
        - 
        - function mk_kagome(L)
      512     kagome = Dict()
        -     idx = 1
        0     L = 2L
        - 
        0     for (i,j) in Iterators.product(1:L,1:L)
        0         mod_site = mod.((i,j),L)
        0         if mod(mod_site[1],2) == 0 && mod(mod_site[2],2) == 1
        -             continue
        -         end
        - 
        0         kagome[idx] = copy.(mod_site)
        0         idx += 1
        -     end
        0     [kagome[i] for i in 1:length(keys(kagome))]
        - end
        - 
        - 
        - 
        - function read_spin_config(file_name::String,num_spins::Int64)
        - 
        -     spins = fill((0.,0.,0.),num_spins)
        - 
        -     open(file_name,"r") do fp
        - 
      176         @assert num_spins == parse(Int64, readline(fp)) "!match num_spins. See 2d.ini and head of spin_config.txt "
        - 
        0         for i in 1:num_spins
     8928             str = split(readline(fp))
        0             sx = parse(Float64, str[1])
        0             sy = parse(Float64, str[2])
        0             sz = parse(Float64, str[3])
        -             
        0             @assert isapprox(sx^2+sy^2+sz^2, 1.0)
        - 
        0             spins[i] = (sx,sy,sz)
        -         end
        -     end
        - 
        -     return spins
        - end
        - 
        - function write_spin_config(file_name::String,spins)
        -     
        -     num_spins = length(spins)
        -     open(file_name,"w") do fp
        -         println(fp,num_spins)
        -         for i in 1:num_spins 
        -             sx,sy,sz = spins[i]
        -             println(fp,sx," ",sy," ",sz)
        -         end
        -     end
        - 
        - end
        -          
        - 
        - function compute_magnetization(acc::Accumulator,num_spins::Int64,spins::Vector{Vector{Tuple{Float64,Float64,Float64}}},num_temps::Int64)
        -     
        -     mx = zeros(Float64, num_temps)
        -     my = zeros(Float64, num_temps)
        -     mz = zeros(Float64, num_temps)
        -     m2 = zeros(Float64, num_temps)
        - 
        -     for i in 1:num_temps
        -       temp_mx = 0.0    
        -       temp_my = 0.0    
        -       temp_mz = 0.0    
        -       for j in 1:num_spins
        -         temp_mx += spins[i][j][1]
        -         temp_my += spins[i][j][2]
        -         temp_mz += spins[i][j][3]
        -       end
        -       mx[i] = temp_mx
        -       my[i] = temp_my
        -       mz[i] = temp_mz
        -       m2[i] = float(mx[i]^2 + my[i]^2+ mz[i]^2)
        -     end
        -     
        -     add!(acc, "Mx2",mx.^2)    
        -     add!(acc, "My2",my.^2)    
        -     add!(acc, "Mz2",mz.^2)
        -     #add!(acc, "M2", m2)
        -     #add!(acc, "M4", m2.^2)
        -    
        -  
        - end
        - 
        - 
        - function get_param(type, conf, block, key, default_value)
        0     if haskey(conf, block, key)
        0         return parse(type, retrieve(conf, block, key))
        -     else
        0         return convert(type, default_value)
        -     end
        - end
        - 
        - function save_result(h5file, acc, comm, res_names)
        -     rank = MPI.Comm_rank(comm)
        -     for r in res_names
        -         data = mean_gather(acc, r, comm)
        -         if rank > 0
        -             continue
        -         end
        -         h5file["obs/"*r] = data
        -     end
        - end
        - 
        - 
        - function solve(input_file::String, comm, prefix, seed_shift)
       80     open(prefix*"out", "w") do outf
        -         solve_(input_file::String, comm, prefix, seed_shift, outf)
        -     end
        - end
        - 
        - function solve_(input_file::String, comm, prefix, seed_shift, outf)
      256     if !isfile(input_file)
        0         error("$input_file does not exists!")
        -     end
        0     conf = ConfParse(input_file)
        0     parse_conf!(conf)
        -     
        0     rank = MPI.Comm_rank(comm)
        0     num_proc = MPI.Comm_size(comm)
        - 
        0     num_spins = get_param(Int64, conf, "model", "num_spins", 0)
        0     Jij_file = retrieve(conf, "model", "Jij")
        0     temperature_file = retrieve(conf, "model", "temperatures")
        0     is_xy = get_param(Bool, conf, "model", "xy_spins", false)
        0     if rank == 0 && is_xy
        0         println(outf, "Using XY spins")
        -     end
        - 
        0     num_sweeps       = parse(Int64, retrieve(conf, "simulation", "num_sweeps"))
        0     num_therm_sweeps = parse(Int64, retrieve(conf, "simulation", "num_therm_sweeps"))
        0     meas_interval    = parse(Int64, retrieve(conf, "simulation", "meas_interval"))
        0     ex_interval      = parse(Int64, retrieve(conf, "simulation", "ex_interval"))
       16     seed             = parse(Int64, retrieve(conf, "simulation", "seed"))
        0     opt_temps_dist   = get_param(Bool,       conf, "simulation", "opt_temps_dist", true)
        0     min_attemps_update_temps_dist  = get_param(Int64,  conf, "simulation", "min_attemps_update_temps_dist", 100)
        - 
        -     # Si Sj
        0     num_src_triangles_sisj = get_param(Int64, conf, "simulation", "num_src_triangles_sisj", 5)
        - 
        -     # Non-equilibrium relaxation method.
        0     use_neq = get_param(Bool, conf, "simulation", "neq", false)
        - 
        0     if opt_temps_dist && 5*min_attemps_update_temps_dist*ex_interval > num_therm_sweeps/2
        0         error("num_therm_sweeps is too small for optimizing temps_dist!")
        -     end
        - 
        -     # For loop updates
        0     loop_num_trial  = parse(Int64, retrieve(conf, "loop_update", "num_trial"))
       16     max_loop_length = parse(Int64, retrieve(conf, "loop_update", "max_loop_length"))
        0     loop_interval   = get_param(Int64, conf, "loop_update", "interval", 10)
        - 
        -     # Read a list of temperatures
        0     temps = read_temps(temperature_file)
        0     num_temps = length(temps)
        0     if num_temps < num_proc
        0         error("Number of processes > num_temps")
        -     end
        0     if rank == 0
        0        println(outf, "num of temperatures = ", num_temps)
        -     end
        - 
        -     # Decide which temperatures are computed on this process
        0     start_idx, end_idx = distribute_temps(rank, num_temps, num_proc)
        0     num_temps_local = end_idx - start_idx + 1
        - 
        -     # Read non-zero elements in the right-upper triangle part of Jij
      160     model = JModel(Jij_file, num_spins)
        - 
        -     # Create single-spin flip updater
        0     updater = SingleSpinFlipUpdater(model)
        - 
        -     # Init random number generator
       16     Random.seed!(seed + seed_shift)
        - 
        -     # Create accumulator
      512     acc = Accumulator(num_temps_local)
        - 
        -     # Create accumulator for collecting stat for every process
      512     acc_proc = Accumulator(1)
        - 
        -     # Init spins
        0     spins_local = [fill((1.,0.,0.),num_spins) for _ in 1:num_temps_local]
        - 
        -     # Work arrays
        0     spins_array = [zeros(Float64, 3, num_spins) for _ in 1:num_temps_local]
        -     
        -     # Optional init spin configuration.
        0     is_read_spin_config = get_param(Bool, conf, "simulation", "read_spin_config", false)
        0     if use_neq && !is_read_spin_config
        0         error("Set read_spin_config for neq!")
        -     end
        0     if is_read_spin_config
        0         spin_config_file = retrieve(conf, "model", "spin_config")
      832         spins_local = fill(read_spin_config(spin_config_file,num_spins),num_temps_local)
        -     end
        - 
        -     # Create upward and downward triangles for computing order parameters.
        0     utriangles_file    = retrieve(conf, "model", "utriangles")
        0     upward_triangles   = read_triangles(utriangles_file,num_spins)
        0     dtriangles_file    = retrieve(conf, "model", "dtriangles")
        0     downward_triangles = read_triangles(dtriangles_file,num_spins)
        - 
        -     # preoaration for computation of magnetic order parameter mq
        0     kagome = mk_kagome(Int(sqrt(num_spins/3)))
      496     site_pos = [kagome[i] ./ 2 for i in 1:num_spins]
       96     qs   = [(0.0, 0.0), (π/3, π/3)]
        - 
        0     energy_local = [compute_energy(model, spins_local[it]) for it in 1:num_temps_local]
        0     energy_local = [compute_energy(model, spins_local[it]) for it in 1:num_temps_local]
        -     # Replica exchange
        0     rex = ReplicaExchange{HeisenbergSpin}(temps, start_idx, end_idx, num_spins)
        -     #?
        -     #temps = 0
        - 
        -     # Perform MC
        0     last_output_time = time_ns()
        0     if rank == 0
        0         println(outf, "Starting simulation...")
        -     end
        -   
        -     # Create LoopUpdater 
        0     loop_updater = LoopUpdater{HeisenbergSpin}(num_spins, max_loop_length)
        - 
        -     # For measuring acceptance rates
       64     single_spin_flip_acc = zeros(Float64, num_temps_local)
        - 
        -     # Replica exchange
        0     ex_rex = get_param(Bool, conf, "simulation", "ex_rex", false)
        - 
        -     # For measuring an energy histogram
        0     energy_histogram_local = [Float64[] for _ in 1:num_temps_local]
        - 
        -     # For measuring a loop length histogram
        0     loop_length_histogram_local = [Float64[] for _ in 1:num_temps_local]
        - 
        -     # Non-equilibrium relaxation method.
        0     if use_neq
        0         if ex_rex
        0             error("Do not use replica exchange MC with neq!")
        -         end
        0         if num_therm_sweeps > 0
        0             error("Please set num_therm_sweeps to 0 for neq!")
        -         end
        0         for it in 1:num_temps_local
        0             convert_spins_to_array!(spins_local[it], spins_array[it])
        -         end
        - 
       16         init_spins_local = [copy(s) for s in spins_local]
        - 
        -         # initial value of Ferro and AF vector spin chirality.
       64         init_fvc        = zeros(Float64, num_temps_local)
       64         init_afvc       = zeros(Float64, num_temps_local)
       64         init_mq_q0      = zeros(Float64, num_temps_local)
       64         init_mq_sqrt3   = zeros(Float64, num_temps_local)
       64         init_m_120degs  = zeros(Float64, num_temps_local)
        0         for it in 1:num_temps_local
        0             init_fvc[it], init_afvc[it] = compute_vector_chiralities(spins_array[it], upward_triangles, downward_triangles) 
       16             init_mq_q0[it]    = compute_mq((0.,0.),   site_pos,spins_local[it], upward_triangles)
       16             init_mq_sqrt3[it] = compute_mq((1/3,1/3), site_pos,spins_local[it], upward_triangles)
       16             init_m_120degs[it] = compute_m_120degrees(spins_local[it])
        -         end
        0         init_mq_sqrt3 .*= 2 #max value of order parameter for √3×√3 is 0.5
        - 
        0         correlation_func      = [Float64[] for _ in 1:num_temps_local]
        0         fvc_correlation       = [Float64[] for _ in 1:num_temps_local]
        0         afvc_correlation      = [Float64[] for _ in 1:num_temps_local]
        0         mq_q0_correlation     = [Float64[] for _ in 1:num_temps_local]
        0         mq_sqrt3_correlation  = [Float64[] for _ in 1:num_temps_local]
        0         m_120degs_correlation = [Float64[] for _ in 1:num_temps_local]
        0         for it in 1:num_temps_local
       16             tmp = sum([dot(spins_local[it][i], spins_local[it][i]) for i in 1:num_spins])
       16             push!(correlation_func[it],tmp / num_spins)
        -         
        0             temp_fvc, temp_afvc  = compute_vector_chiralities(spins_array[it], upward_triangles, downward_triangles) 
       80             push!(fvc_correlation[it],  init_fvc[it]  * temp_fvc)
       80             push!(afvc_correlation[it], init_afvc[it] * temp_afvc)
        - 
       16             temp_mq_q0     = compute_mq((0.,0.),   site_pos,spins_local[it], upward_triangles)
       16             temp_mq_sqrt3  = compute_mq((1/3,1/3), site_pos,spins_local[it], upward_triangles)
       16             temp_m_120degs = compute_m_120degrees(spins_local[it])
       80             push!(mq_q0_correlation[it],     init_mq_q0[it]     * temp_mq_q0)
       80             push!(mq_sqrt3_correlation[it],  init_mq_sqrt3[it]  * 2 * temp_mq_sqrt3)
       16             push!(m_120degs_correlation[it], init_m_120degs[it] * temp_m_120degs)
        -         end
        - 
        -         #=
        -         maf_time_evo = [Float64[] for _ in 1:num_temps_local]
        -         for it in 1:num_temps_local
        -             push!(maf_time_evo[it], compute_m2_af(spins_local[it], upward_triangles))
        -         end
        -         =#
        -     end
        - 
        - 
        0     for sweep in 1:num_sweeps
        -         # Output roughtly every 10 sececonds
        0         if rank == 0 && time_ns() - last_output_time > 1e+10
        0             println(outf, "Done $sweep sweeps")
        0             last_output_time = time_ns()
        0             flush(stdout)
        -         end
        - 
     6400         elpsCPUtime = Float64[]
        -  
        -         # Single spin flips
        0         ts_start = CPUtime_us()
        -         
        0         for it in 1:num_temps_local
        -             
    14288             dE, acc_rate = gaussian_move(updater, 1/rex.temps[it+start_idx-1], model, spins_local[it], is_xy)
        -             
     4784             energy_local[it] += dE
        0             single_spin_flip_acc[it] = acc_rate
        -         end
        -         #println(outf, "one_sweep", " ",ts_end - ts_start)
     8000         push!(elpsCPUtime, CPUtime_us() - ts_start)
        - 
        -         # Check if energy is correct
        0         if mod(sweep, 100) == 0
        0             energy_local = [compute_energy(model, spins_local[it]) for it in 1:num_temps_local]
        0             for it in 1:num_temps_local
       64                 @assert abs(energy_local[it] - compute_energy(model, spins_local[it])) < 1e-5
        -             end
        -         end
        -          
        -         # Replica exchange
        0         ts_start = CPUtime_us()
        0         if mod(sweep, ex_interval) == 0 && ex_rex == true
        0             perform!(rex, spins_local, energy_local, comm)
        -         end
        0         if opt_temps_dist
        0             if sweep <= Int(num_therm_sweeps/2) && rex.num_attemps >= min_attemps_update_temps_dist
        0                 update_temps_dist!(rex,comm)
        -             end
        -         end
        - 
        0         push!(elpsCPUtime, CPUtime_us() - ts_start)
        - 
        -         # Loop update
        0         ts_start = CPUtime_us()
     6400         loop_found_rate = zeros(Float64, num_temps_local)
     6400         loop_acc_rate = zeros(Float64, num_temps_local)
        0         if loop_num_trial > 0 && mod(sweep, loop_interval) == 0
        0             for it in 1:num_temps_local
        0                 dE, loop_found_rate[it], loop_acc_rate[it] = multi_loop_update!(loop_updater, loop_num_trial,
        -                     updater,
        -                     1/rex.temps[it+start_idx-1],
        -                     max_loop_length, spins_local[it], rank==0)
        0                 energy_local[it] += dE
        -             end
        -         end
        0         push!(elpsCPUtime, CPUtime_us() - ts_start)
        - 
        -         # Measurement
        0         ts_start = CPUtime_us()
        0         if sweep >= num_therm_sweeps && mod(sweep, meas_interval) == 0
        -             # Convert spin config to arrays
        0             for it in 1:num_temps_local
        0                 convert_spins_to_array!(spins_local[it], spins_array[it])
        -             end
        - 
     3168             add!(acc, "E", energy_local)
    11168             add!(acc, "E2", energy_local.^2)
        0             add!(acc, "single_spin_flip_acc", single_spin_flip_acc)
        -             
        0             add!(acc, "loop_found_rate" , loop_found_rate)
        0             add!(acc, "loop_accept_rate", loop_acc_rate)
        -           
        -             # energy histgrams
        0             for it in 1:num_temps_local
     1600                 push!(energy_histogram_local[it],energy_local[it])
        -             end
        - 
        -             #=
        -             # loop length,candidate order parameter
        -             measured_loop_length = zeros(Int64, num_temps_local)
        -             for it in 1:num_temps_local
        -                 long_loop_counter = 0 
        -                 measured_loop_length[it] = compute_loop_length(spins_local[it],
        -                                                                updater,
        -                                                                loop_updater,
        -                                                                max_loop_length,
        -                                                                false)
        -                 L = sqrt(num_spins/3)
        -                 # diagonal length of the system = 2*sqrt(2)*L 
        -                 if measured_loop_length[it] > 10 * 2 * sqrt(2) * L && long_loop_counter < 10
        -                     long_loop_counter += 1
        -                     write_spins_on_loop("spin_index_$(it+start_idx-1)_$(long_loop_counter).txt",loop_updater)
        -                     write_spin_config("spin_config_$(it+start_idx-1)_w_long_loop_$(long_loop_counter).txt",spins_local[it])
        -                 end
        - 
        -                 push!(loop_length_histogram_local[it],measured_loop_length[it])
        - 
        -             end
        -  
        -             if !in(0,measured_loop_length)
        -                 add!(acc,"loop_length",measured_loop_length)
        -             end
        -             
        -             add!(acc,"loop_length",measured_loop_length)
        -             =#
        - 
        -             # square and fourth power of magnetic and chirality order parameters
     6400             m2_af = zeros(Float64,num_temps_local)
     6400             T2_op = zeros(Float64,num_temps_local)
        0             for it in 1:num_temps_local
        0                 m2_af[it] = compute_m2_af(spins_local[it], upward_triangles)
        0                 T2_op[it] = compute_T2_op(spins_local[it], num_spins)
        -             end
        0             add!(acc, "m_af_2", m2_af)
        0             add!(acc, "T_op_2", T2_op)
     6400             add!(acc, "m_af_4", m2_af.^2)
     6400             add!(acc, "T_op_4", T2_op.^2)
        - 
     6400             mq_q0     = zeros(Float64, num_temps_local)
     6400             mq_sqrt3  = zeros(Float64, num_temps_local)
     6400             m_120degs = zeros(Float64, num_temps_local)
        -             #ss        = [zeros(Float64,3,num_spins) for _ in 1:num_temps_local]
        -             #sisj      = Vector{Array{Float64,3}}(undef, num_temps_local)
        0             for it in 1:num_temps_local
     1600                 mq_q0[it]    = compute_mq((0.,0.),   site_pos,spins_local[it], upward_triangles)
     1600                 mq_sqrt3[it] = compute_mq((1/3,1/3), site_pos,spins_local[it], upward_triangles)
     1600                 m_120degs[it]= compute_m_120degrees(spins_local[it])
        -                 #=
        -                 sisj[it] = compute_sisj(num_src_triangles_sisj, spins_local[it], upward_triangles)
        -                 =#
        -                 #for is in 1:num_spins, j in 1:3
        -                     #temp_idx = upward_triangles[1][j]
        -                     #ss[it][j,is] = spins_local[it][is]⋅spins_local[it][temp_idx]
        -                 #end
        -             end
        0             add!(acc, "mq0_2",      mq_q0)
        0             add!(acc, "msqrt_2",    mq_sqrt3)
        0             add!(acc, "m120degs_2", m_120degs)
     6400             add!(acc, "mq0_4",      mq_q0.^2)
     6400             add!(acc, "msqrt_4",    mq_sqrt3.^2)
     6400             add!(acc, "m120degs_4", m_120degs.^2)
        -             #add!(acc,"ss",ss)
        -             #add!(acc,"sisj", sisj)
        - 
        -             # ferro and anti-ferro vector spin chirality
     6400             fvc  = zeros(Float64, num_temps_local)
     6400             afvc = zeros(Float64, num_temps_local)
     4800             vc_corrs = Vector{Float64}[]
        0             for it in 1:num_temps_local
        0                 fvc[it], afvc[it] = compute_vector_chiralities(spins_array[it], upward_triangles, downward_triangles)
        -                 #push!(vc_corrs, vc_corr)
        -             end
        0             add!(acc, "Ferro_vc_2", fvc)
        0             add!(acc, "AF_vc_2",    afvc)
     6400             add!(acc, "Ferro_vc_4", fvc.^2)
     6400             add!(acc, "AF_vc_4",    afvc.^2)
        -             #add!(acc,"vc_corr", vc_corrs)
        - 
        -             # non-equilibrium relaxation method.
        0             if use_neq
        0                 for it in 1:num_temps_local
        - 
     1600                     tmp = sum([dot(init_spins_local[it][i], spins_local[it][i]) for i in 1:num_spins])
     1600                     push!(correlation_func[it], tmp / num_spins)
        - 
     1824                     push!(fvc_correlation[it],  init_fvc[it]  * fvc[it])
     1824                     push!(afvc_correlation[it], init_afvc[it] * afvc[it])
        - 
     1824                     push!(mq_q0_correlation[it],     init_mq_q0[it]      * mq_q0[it])
     1824                     push!(mq_sqrt3_correlation[it],  init_mq_sqrt3[it]   * 2 * mq_sqrt3[it])
     1824                     push!(m_120degs_correlation[it], init_m_120degs[it]  * m_120degs[it])
        -                     if mod(sweep, 100) == 0
        -                         #println(outf, sweep, "th: ", tmp/num_spins)
        0                     end
        -   
        -                 end
        - 
        -                 #=
        -                 for it in 1:num_temps_local
        -                     temp_maf = compute_m2_af(spins_local[it],upward_triangles)
        -                     push!(maf_time_evo[it],maf_time_evo[it][1]*temp_maf)
        -                 end 
        -                 =#
        - 
        -             end
        -         end
        0         push!(elpsCPUtime, CPUtime_us() - ts_start)
        - 
        0         if sweep > num_therm_sweeps
    16000             add!(acc_proc, "CPUtime", [Vector{Float64}(elpsCPUtime)])
        -         end
        -     end        
        - 
        -     #for it in 1:num_temps_local
        -       #dE,num_accept = multi_loop_update!(loop_num_trial,loop_num_reference_sites,updater,1/rex.temps[it+start_idx-1],triangles,max_loop_length,spins_local[it],rank==0)
        -     #end
        -  
        -     # Output results
        0     E = mean_gather(acc, "E", comm)
        0     E2 = mean_gather(acc, "E2", comm)
        0     single_spin_flip_acc = mean_gather(acc, "single_spin_flip_acc", comm)
        0     loop_found_rate = mean_gather(acc,"loop_found_rate", comm)
        0     loop_accept_rate = mean_gather(acc,"loop_accept_rate", comm)
        0     CPUtime = mean_gather_array(acc_proc, "CPUtime", comm)
        -     #ave_loop_length = mean_gather(acc,"loop_length",comm)
        0     m2_af = mean_gather(acc, "m_af_2", comm)
        0     T2_op = mean_gather(acc, "T_op_2", comm)
        0     m2q_q0 = mean_gather(acc, "mq0_2", comm)
        0     m2q_sqrt3 = mean_gather(acc, "msqrt_2", comm)
        0     m120degs2 = mean_gather(acc, "m120degs_2", comm)
        0     Ferro_vc2 = mean_gather(acc, "Ferro_vc_2", comm)
        0     AF_vc2    = mean_gather(acc, "AF_vc_2"   , comm)
        0     m4_af = mean_gather(acc, "m_af_4", comm)
        0     T4_op = mean_gather(acc, "T_op_4", comm)
        0     m4q_q0 = mean_gather(acc, "mq0_4", comm)
        0     m4q_sqrt3 = mean_gather(acc, "msqrt_4", comm)
        0     m120degs4 = mean_gather(acc, "m120degs_4", comm)
        0     Ferro_vc4 = mean_gather(acc, "Ferro_vc_4", comm)
        0     AF_vc4    = mean_gather(acc, "AF_vc_4"   , comm)
        -     #ss    = mean_gather_array(acc, "ss" , comm)
        -     #vc_corr = mean_gather_array(acc, "vc_corr" , comm)
        0     flush(stdout)
        0     MPI.Barrier(comm)
        - 
        0     flush(stdout)
        0     MPI.Barrier(comm)
        -   
        0     for it in 1:num_temps_local
        -         #write_spin_config("spin_config_$(it+start_idx-1).txt",spins_local[it])
        0     end
        -   
        - 
        -     # To save to HDF5 file,add correlation functions to accumulator.
        0     if use_neq
        0         add!(acc,"Gt",             correlation_func)
        0         add!(acc,"fvc_corr",       fvc_correlation)
        0         add!(acc,"afvc_corr",      afvc_correlation)
        0         add!(acc,"mq_q0_corr",     mq_q0_correlation)
        0         add!(acc,"mq_sqrt3_corr",  mq_sqrt3_correlation)
        0         add!(acc,"m_120degs_corr", m_120degs_correlation)
        -     end
        -  
        -     # To save to HDF5 file,add energy histgrams to accumulator.
        0     add!(acc,"energy_histogram", energy_histogram_local)
        - 
        -     # To save to HDF5 file,add loop length histgrams to accumulator.
        0     add!(acc,"loop_length_histogram", loop_length_histogram_local)
        - 
        -     #add!(acc,spins_local)
        - 
        -     # Output time evolution of order parameter.
        -     #=
        -     if use_neq
        -         for itemp in 1:num_temps_local
        - 
        -             open(prefix*"Gt_$(itemp+start_idx-1).dat","w") do fp
        -                for itime in 1:length(correlation_func[itemp])
        -                    println(fp, itime, " ", correlation_func[itemp][itime])
        -                end
        -             end
        - 
        -             open(prefix*"maf_$(itemp+start_idx-1).dat","w") do fp
        -                #for itime in 1:length(maf_time_evo[itemp])
        -                    #println(fp, itime, " ", maf_time_evo[itemp][itime])
        -                #end
        -             end
        - 
        -             open(prefix*"fvc_$(itemp+start_idx-1).dat","w") do fp
        -                for itime in 1:length(fvc_correlation[itemp])
        -                    println(fp, itime, " ", fvc_correlation[itemp][itime])
        -                end
        -             end
        - 
        -             open(prefix*"afvc_$(itemp+start_idx-1).dat","w") do fp
        -                for itime in 1:length(afvc_correlation[itemp])
        -                    println(fp, itime, " ", afvc_correlation[itemp][itime])
        -                end
        -             end
        - 
        -             open(prefix*"mq_q0_$(itemp+start_idx-1).dat","w") do fp
        -                 for itime in 1:length(mq_q0_correlation[itemp])
        -                    println(fp, itime, " ", mq_q0_correlation[itemp][itime])
        -                 end
        -             end
        - 
        -             open(prefix*"mq_sqrt3_$(itemp+start_idx-1).dat","w") do fp
        -                 for itime in 1:length(mq_sqrt3_correlation[itemp])
        -                    println(fp, itime, " ", mq_sqrt3_correlation[itemp][itime])
        -                 end
        -             end
        - 
        -             open(prefix*"m_120degs_$(itemp+start_idx-1).dat","w") do fp
        -                 for itime in 1:length(m_120degs_correlation[itemp])
        -                    println(fp, itime, " ", m_120degs_correlation[itemp][itime])
        -                 end
        -             end
        - 
        -         end
        -     end
        -     =#
        - 
        0     if rank == 0
        0         println(outf)
      576         open(prefix*"E.txt", "w") do f
        0             println(f, "#T <E> <E^2> <C>")
        0             for i in 1:num_temps
       64                 println(f, "$(rex.temps[i]) $(E[i]) $(E2[i]) $(((E2[i]  - E[i]^2) / (rex.temps[i]^2)) / num_spins)")
       64                 println(outf, "$(rex.temps[i]) $(E[i]) $(E2[i]) $(((E2[i]  - E[i]^2) / (rex.temps[i]^2)) / num_spins)")
        -             end
        -         end
        -       
      144         println(outf, "single_spin_flip_acc: ", single_spin_flip_acc)
        0         println(outf, "Acceptant rate of loop update: ")
        0         for i in 1:num_temps
       48             println(outf, rex.temps[i], " ", loop_found_rate[i], " ", loop_accept_rate[i])
        -         end
        - 
        0         println(outf, "<CPUtime> ")
       80         for (i, t) in enumerate(CPUtime)
        0             println(outf, " rank=", i-1, " : $t")
        -         end
        -     
        -         # update initial temperature distribution.        
       80         open(prefix*"temperatures.txt","w") do fp
        -              println(fp,num_temps)
        -              for i in 1:num_temps
        -                  println(fp,rex.temps[i])
        -              end
        -         end
        -      
        0         for i in 1:num_temps
     1088             println(outf, "af2: $(rex.temps[i]) $(m2_af[i])")
     1088             println(outf, "op2: $(rex.temps[i]) $(T2_op[i])")
     1104             println(outf, "Ferro_vc2: $(rex.temps[i]) $(Ferro_vc2[i])")
     1104             println(outf, "AF_vc2: $(rex.temps[i]) $(AF_vc2[i])")
     1088             println(outf, "m2q0: $(rex.temps[i]) $(m2q_q0[i])")
     1104             println(outf, "m2_sqrt3: $(rex.temps[i]) $(m2q_sqrt3[i])")
     1104             println(outf, "m120degs2: $(rex.temps[i]) $(m120degs2[i])")
     1088             println(outf, "af4: $(rex.temps[i]) $(m4_af[i])")
     1088             println(outf, "op4: $(rex.temps[i]) $(T4_op[i])")
     1104             println(outf, "Ferro_vc4: $(rex.temps[i]) $(Ferro_vc4[i])")
     1104             println(outf, "AF_vc4: $(rex.temps[i]) $(AF_vc4[i])")
     1088             println(outf, "m4q0: $(rex.temps[i]) $(m4q_q0[i])")
     1104             println(outf, "m4_sqrt3: $(rex.temps[i]) $(m4q_sqrt3[i])")
     1104             println(outf, "m120degs4: $(rex.temps[i]) $(m120degs4[i])")
        -         end
        - 
       32         h5open(prefix*"corr.h5", "w") do fid
        -             # ss is an array of arrays of shape (3, num_spins).
        -             # We "reshape" it into an array of shape (3, num_spins, num_temps).
        -             #tmp = cat(ss[:,:,CartesianIndex()]..., dims=3)
        -             #println(size(tmp))
        -             #fid["ss"] = cat(ss[:,:,CartesianIndex()]..., dims=3)
        -             #fid["vc"] = cat(vc_corr[:,CartesianIndex()]..., dims=2)
        -         end
        -     end
        0     flush(stdout)
        0     MPI.Barrier(comm)
        - 
        0     fid = nothing
        0     if rank == 0
       32         fid = h5open(prefix*"out.h5" , "w")
       64         fid["temperatures"] = rex.temps
        -     end
        0     save_to_hdf5!(acc, fid, comm)
        0     if rank == 0
        0         close(fid)
        -     end
        - 
        -     #=
        -     obs_names = String[]
        -     for base_name in ["m_af", "T_op", "mq0", "msqrt", "m120degs", "Ferro_vc", "AF_vc"]
        -         push!(obs_names, base_name*"_2")
        -         push!(obs_names, base_name*"_4")
        -     end
        -     fid = nothing
        -     if rank == 0
        -         fid = h5open(prefix*"out.h5" , "w")
        -         fid["temperatures"] = temps
        -     end
        -     save_result(fid, acc, comm, obs_names)
        -     =#
        - 
        -     # Stat of Replica Exchange MC
        0     print_stat(rex, comm, outf)
        - end
        - 
        - end
